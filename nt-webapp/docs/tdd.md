# Technical Design Document: NT Bird Monitor Webapp

## 1. Project Overview
* **Description**: A web-based dashboard to visualize and interact with bird call detection data processed by the `nt-bird-detect` pipeline.
* **Objective**: To provide an intuitive interface for viewing bird species counts, timestamps, and acoustic insights generated from sensor data.

---

## 2. Technology Stack
| Layer | Technology | Purpose |
| :--- | :--- | :--- |
| **Frontend** | React.js (Vite) | UI Components & Data Visualization |
| **Backend** | Python Flask | RESTful API to serve "Gold" layer data |
| **Database** | Parquet / SQLite | Processed analytics from the `nt-bird-detect` pipeline |
| **Proxy/Server** | **Nginx** | Serves static `dist` files and proxies API calls |
| **Containerization**| **Docker** | Ensures consistent environment across dev/prod |
| **Orchestration** | **Docker Compose**| Manages the Frontend, Backend, and Nginx services |

---

## 3. System Architecture
The application uses a **Containerized Client-Server Architecture** behind an Nginx reverse proxy.

* **Traffic Flow**: 
    1.  User visits port `80` (HTTP).
    2.  Nginx intercepts the request.
    3.  **Frontend**: If the request is for a UI page, Nginx serves static files from the `frontend/dist` folder.
    4.  **Backend**: If the request starts with `/api`, Nginx forwards (proxies) it to the Flask container on port `5000`.

nt-webapp/
â”œâ”€â”€ docs/                      # Project documentation (TDD, architecture)
â”œâ”€â”€ webapp/                    # Main application root
â”‚   â”œâ”€â”€ docker-compose.yml     # Service orchestration
â”‚   â”œâ”€â”€ backend/               # Flask API service
â”‚   â”‚   â”œâ”€â”€ api.py             # Main entry point for the API
â”‚   â”‚   â”œâ”€â”€ Dockerfile         # Python environment configuration
â”‚   â”‚   â””â”€â”€ requirements.txt   # Python dependencies
â”‚   â”œâ”€â”€ frontend/              # React/Vite UI service
â”‚   â”‚   â”œâ”€â”€ Dockerfile         # Node/Nginx multi-stage build
â”‚   â”‚   â”œâ”€â”€ nginx.conf         # Proxy and routing configuration
â”‚   â”‚   â”œâ”€â”€ package.json       # React dependencies
â”‚   â”‚   â””â”€â”€ src/               # React components and logic
â”‚   â””â”€â”€ nginx/                 # (Optional) Global Nginx templates
â””â”€â”€ .gitignore                 # Root-level Git exclusion rules

---

## 4. Data Integration (The "Gold" Layer)
The webapp does not process raw audio. It consumes the analytical output of the `nt-bird-detect` pipeline.

* **Source Path**: `../../nt-bird-detect/data/analytics/`
* **Format**: Cleaned Parquet files (Gold Layer).
* **Sync**: The Docker container mounts the analytics folder as a **volume**, allowing the Flask app to access updated data as the pipeline finishes its run.

---

## 5. API Specification
The Flask backend exposes the following endpoints:

| Endpoint | Method | Description | Data Source |
| :--- | :--- | :--- | :--- |
| `/api/summary` | GET | Total bird counts and species list | `bird_counts.parquet` |
| `/api/detections` | GET | List of specific detection events | `processed_detections.parquet` |
| `/api/health` | GET | Checks API and data access status | System Check |

---

## 6. Infrastructure & Docker Logic
### Service Definitions
* **`frontend` service**: Built using a multi-stage Dockerfile starting with Node 22 (Alpine) to support Vite 7 asset hashing.
    - 20260119_old: Built using an Nginx image. It hosts the production-ready assets generated by Vite in the `/dist` directory.
* **`backend` service**: Runs Gunicorn for production-grade concurrency.
    - 20260119_old: Runs Gunicorn/Flask. Includes `pandas` and `pyarrow` to read the Parquet files from the mounted volume.

---

## 7. Frontend Structure (Vite)
The React app is built with **Vite**, optimizing for speed and modern ESM support.

* **/src/components**: Reusable UI elements (Charts, SpeciesCards).
* **/src/pages**: Main views (Dashboard, History).
* **/dist**: The production-ready output directory created by `npm run build`.


## 8. ğŸ–¼ï¸ Asset Management

### 1. Static Assets (Images/Photos)
To keep the repository size manageable and optimize performance, images are handled as follows:

* **Location**: All large UI assets (backgrounds, reference photos) are stored in `frontend/public/background_images/`.
* **Referencing**: In React/CSS, these are accessed via absolute paths (e.g., `/background_images/filename.jpg`) without requiring JavaScript imports.
* **Git Exclusion**: To prevent large binary files from bloating the Git history, the entire folder is excluded from version control.

### 2. Update .gitignore
The following pattern is added to the root `.gitignore` file to ensure local assets do not get pushed to GitHub:
# Exclude local UI assets
frontend/public/background_images/


---


## ğŸ“¦ Versioning & Recovery Strategy (v1.01+)

### 1. Creating a Milestone Build (e.g., v1.01)
When the dashboard reaches a stable state, "freeze" the current code into a tagged Docker image.

1. **Update Version Tags**: In `docker-compose.yml`, set the `image:` name for your services:
   ```yaml
   services:
     backend:
       image: webapp-backend:v1.01
     frontend:
       image: webapp-frontend:v1.01

2. **Generate the Image**: Run the build command to lock the current code into the Docker library:

Bash

docker-compose up --build -d

3. **Tag the Source Code**: Sync your local files with the Docker version using Git to ensure you can find this exact code later:

Bash

git add .
git commit -m "Stable v1.01: Added Analytics Layer and Dashboard Toggle"
git tag -a v1.01 -m "Version 1.01 stable"

### 2. Daily Development Workflow
To avoid cluttering your Docker library with numerous version numbers during active coding, use the latest tag.

Toggle to Dev: Comment out the versioned lines in docker-compose.yml and use latest:

YAML

# image: webapp-backend:v1.01
image: webapp-backend:latest
Iterate: Run docker-compose up --build as needed to refresh the latest image with your most recent code changes.

### 3. Emergency Recovery Procedure
If the "latest" version breaks or local files become corrupted, use this two-step recovery process.

#### A. Revert the Live Environment (Docker)
Restore the browser-facing application to a known working state immediately:
1. Modify Configuration: Point docker-compose.yml back to the stable tag: image: webapp-backend:v1.01.
2. Deploy Snapshot: Run docker-compose up -d (without the --build flag).
3. Outcome: Docker will ignore your broken local files and run the "frozen" code stored inside the v1.01 image.

#### B. Revert Local Source Code (Git)
Reset your text files on your Mac to match the stable version to resume work from a clean slate:

Bash

# Warning: This will overwrite local changes to match the v1.01 tag
git reset --hard v1.01




## 8. Development Roadmap