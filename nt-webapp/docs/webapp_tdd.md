# Technical Design Document: NT Bird Monitor Webapp

## 1. Project Overview
* **Description**: A web-based dashboard to visualize and interact with bird call detection data processed by the `nt-bird-detect` pipeline.
* **Objective**: To provide an intuitive interface for viewing bird species counts, timestamps, and acoustic insights generated from sensor data.

---

## 2. Technology Stack
| Layer | Technology | Purpose |
| :--- | :--- | :--- |
| **Frontend** | React.js (Vite) | UI Components & Data Visualization |
| **Backend** | Python Flask | RESTful API to serve "Gold" layer data |
| **Database** | Parquet / SQLite | Processed analytics from the `nt-bird-detect` pipeline |
| **Proxy/Server** | **Nginx** | Serves static `dist` files and proxies API calls |
| **Containerization**| **Docker** | Ensures consistent environment across dev/prod |
| **Orchestration** | **Docker Compose**| Manages the Frontend, Backend, and Nginx services |

---

## 3. System Architecture
The application uses a **Containerized Client-Server Architecture** behind an Nginx reverse proxy.

* **Traffic Flow**: 
    1.  User visits port `80` (HTTP).
    2.  Nginx intercepts the request.
    3.  **Frontend**: If the request is for a UI page, Nginx serves static files from the `frontend/dist` folder.
    4.  **Backend**: If the request starts with `/api`, Nginx forwards (proxies) it to the Flask container on port `5000`.

nt-webapp/
‚îú‚îÄ‚îÄ docs/                      # Project documentation (TDD, architecture)
‚îú‚îÄ‚îÄ webapp/                    # Main application root
‚îÇ   ‚îú‚îÄ‚îÄ docker-compose.yml     # Service orchestration
‚îÇ   ‚îú‚îÄ‚îÄ backend/               # Flask API service
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api.py             # Main entry point for the API
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile         # Python environment configuration
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ requirements.txt   # Python dependencies
‚îÇ   ‚îú‚îÄ‚îÄ frontend/              # React/Vite UI service
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile         # Node/Nginx multi-stage build
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ nginx.conf         # Proxy and routing configuration
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ package.json       # React dependencies
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ src/               # React components and logic
‚îÇ   ‚îî‚îÄ‚îÄ nginx/                 # (Optional) Global Nginx templates
‚îî‚îÄ‚îÄ .gitignore                 # Root-level Git exclusion rules

---

## 4. Data Integration (The "Gold" Layer)
The webapp does not process raw audio. It consumes the analytical output of the `nt-bird-detect` pipeline.

* **Source Path**: `../../nt-bird-detect/data/analytics/`
* **Format**: Cleaned Parquet files (Gold Layer).
* **Sync**: The Docker container mounts the analytics folder as a **volume**, allowing the Flask app to access updated data as the pipeline finishes its run.

---

## 5. API Specification
The Flask backend exposes the following endpoints:

| Endpoint | Method | Description | Data Source |
| :--- | :--- | :--- | :--- |
| `/api/summary` | GET | Total bird counts and species list | `bird_counts.parquet` |
| `/api/detections` | GET | List of specific detection events | `processed_detections.parquet` |
| `/api/health` | GET | Checks API and data access status | System Check |

---

## 6. Infrastructure & Docker Logic
### Service Definitions
* **`frontend` service**: Built using a multi-stage Dockerfile starting with Node 22 (Alpine) to support Vite 7 asset hashing.
    - 20260119_old: Built using an Nginx image. It hosts the production-ready assets generated by Vite in the `/dist` directory.
* **`backend` service**: Runs Gunicorn for production-grade concurrency.
    - 20260119_old: Runs Gunicorn/Flask. Includes `pandas` and `pyarrow` to read the Parquet files from the mounted volume.

---

## 7. Frontend Structure (Vite)
The React app is built with **Vite**, optimizing for speed and modern ESM support.

* **/src/components**: Reusable UI elements (Charts, SpeciesCards).
* **/src/pages**: Main views (Dashboard, History).
* **/dist**: The production-ready output directory created by `npm run build`.


## 8. üñºÔ∏è Asset Management

### 1. Static Assets (Images/Photos)
To keep the repository size manageable and optimize performance, images are handled as follows:

* **Location**: All large UI assets (backgrounds, reference photos) are stored in `frontend/public/background_images/`.
* **Referencing**: In React/CSS, these are accessed via absolute paths (e.g., `/background_images/filename.jpg`) without requiring JavaScript imports.
* **Git Exclusion**: To prevent large binary files from bloating the Git history, the entire folder is excluded from version control.

### 2. Update .gitignore
The following pattern is added to the root `.gitignore` file to ensure local assets do not get pushed to GitHub:
# Exclude local UI assets
frontend/public/background_images/


## üß™ Data Processing (BirdNET Pipeline)

### Optimization Protocols
To maintain performance as the "DataLoad" volume increases, the following rules are applied to `process_audio_data_files.py`:

* **Manifest-First Check**: The `processing_manifest.parquet` is queried before any analysis to prevent redundant CPU cycles on previously analyzed files.
* **Atomic Writes**: (Proposed) The script should transition to periodic saves to prevent data loss during long-running batch jobs.
* **Storage Schema**: Detections are stored in Parquet format to ensure high compression and fast read times for the Flask API.

### 3. Memory & I/O Optimization
To prevent memory exhaustion during long-duration monitoring, the pipeline follows an "Atomic Load-and-Clear" pattern:
* **Scope**: Dataframes (`df_existing`, `df_combined`) are scoped inside the file-processing loop, ensuring RAM is released after every file is saved.
* **File Persistence**: Parquet files are closed immediately after I/O operations, preventing file-locking issues.
* **Daily Partitioning**: RAM usage is capped by the maximum detections per 24-hour period, rather than the total project history.



---


## üì¶ Versioning & Recovery Strategy (v1.01+)

### 1. Creating a Milestone Build (e.g., v1.01)
When the dashboard reaches a stable state, "freeze" the current code into a tagged Docker image.

1. **Update Version Tags**: In `docker-compose.yml`, set the `image:` name for your services:
   ```yaml
   services:
     backend:
       image: webapp-backend:v1.01
     frontend:
       image: webapp-frontend:v1.01

2. **Generate the Image**: Run the build command to lock the current code into the Docker library:

Bash

docker-compose up --build -d

3. **Tag the Source Code**: Sync your local files with the Docker version using Git to ensure you can find this exact code later:

Bash

git add .
git commit -m "Stable v1.01: Added Analytics Layer and Dashboard Toggle"
git tag -a v1.01 -m "Version 1.01 stable"

### 2. Daily Development Workflow
To avoid cluttering your Docker library with numerous version numbers during active coding, use the latest tag.

Toggle to Dev: Comment out the versioned lines in docker-compose.yml and use latest:

YAML

# image: webapp-backend:v1.01
image: webapp-backend:latest
Iterate: Run docker-compose up --build as needed to refresh the latest image with your most recent code changes.

### 3. Emergency Recovery Procedure
If the "latest" version breaks or local files become corrupted, use this two-step recovery process.

#### A. Revert the Live Environment (Docker)
Restore the browser-facing application to a known working state immediately:
1. Modify Configuration: Point docker-compose.yml back to the stable tag: image: webapp-backend:v1.01.
2. Deploy Snapshot: Run docker-compose up -d (without the --build flag).
3. Outcome: Docker will ignore your broken local files and run the "frozen" code stored inside the v1.01 image.

#### B. Revert Local Source Code (Git)
Reset your text files on your Mac to match the stable version to resume work from a clean slate:

Bash

# Warning: This will overwrite local changes to match the v1.01 tag
git reset --hard v1.01




## 8. Development Roadmap